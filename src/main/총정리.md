## 총정리

| 패턴 이름                    |     수호 원칙      | 목적                                                      | 정의                                                                                                                              |
|--------------------------|:--------------:|---------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------|
| Strategy Pattern         |      OCP       | 달라지는 부분을 찾아내고, 달라지지 않는 않부분으로부터 분리 시킨다                   | 알고리즘군을 정의하고 각각을 캡슐화하여 교환해서 사용할 수 있도록 만든다                                                                                        |
| Observer Pattern         | Loose Coupling | 서로 상호작용을 하는 객체 사이에서는 가능하면 느슨한 결합을 하는 디자인을 사용한다          | 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체들에게 연락이 가고 자동으로 내용이 갱신되는 방식으로 일대다 의존성을 정의한다                                                       |
| Decorator Pattern        |      OCP       | OCP 클래스는 확장에 대해서는 열려 있어야 하지만 코드 변경에 대해서는 닫혀 있어야 한다      | 객체에 추가적인 요건을 동적으로 첨가한다. 데코레이터는 서브클래스를 만드는 것을 통해서 기능을 유연하게 확장할 수 있는 방법을 제공한다                                                     |
| Factory Method Pattern   |      OCP       | 객체 생성의 캡슐화                                              | 팩토리 메소드 패턴에서는 객체를 생성하기 위한 인터페이스를 정의하는데, 어떤 클래스의 인스턴스를 만들지는 서브 클래스에서 결정하게 만든다                                                    |
| Abstract Factory Pattern |      OCP       | 의존성 뒤집기 원칙을 따르면 구상 형식에 대한 의존을 피하고 추상화를 지향할 수 있다         | 추상 팩토리 패턴에서는 인터페이스를 이용하여 서로 연관된, 또는 의존하는 객체를 구상 클래스를 지정하지 않고도 생성할 수 있다                                                          |
| Singleton Pattern        |                | 클래스 인스턴스가 하나만 만들어지도록 하고, 그 인스턴스에 대한 전역 접근을 제공한다         | 싱글턴 패턴은 해당 클래스의 인스턴스가 하나만 만들어지고, 어디서든지 그 인스턴스에 접근할 수 있도록 하기 위한 패턴이다                                                             |
| Command Pattern          |      OCP       | 요청을 하는 객체와 그 요청을 수행하는 객체를 분리 시킨다 (캡슐화)                  | 커맨드 패턴을 이용하면 요구 사항을 객체로 캡슐화 할 수 있으며, 매개변수를 써서 여러 가지 다른 요구 사항을 집어넣을 수도 있다       또한 요청 내역을 큐에 저장하거나 로그로 기록할 수도 있으며, 작업취소 기능도 지원한다 |
| Adapter Pattern          |                | 어답터를 이용하면 인터페이스 호환성 문제 때문에 같이 쓸 수 없는 클래스들을 연결해서 쓸수 있다   | 한 클래스의 인터페이스를 클라이언트에서 사용하고자 하는 다른 인터페이스로 변환한다                                                                                   |
| Facade Pattern           |    최소 지식 원칙    | 사용하기 쉬운 인터페이스를 제공함과 동시에 클라이언트와 구성요소들로 이루어진 서브시스템을 분리시킨다 | 어떤 서브시스템의 일련의 인터페이스에 대한 통합된 인터페이스를 제공한다. 퍼사드에서 고수준 인터페이스를 정의하기 때문에 서브시스템을 쉽게 사용할 수 있다                                           |
| Template Pattern         |     할리우드 원칙     |  템플릿 메소드를 제공해서 서브클래스가 구현할 수 있도록 하게 해준다 | 메소드에서 알고리즘의 골격을 정의한다. 알고리즘의 여러 단계 중 일부는 서브클래스에서 구현할 수 있다. 템플릿 메소드를 이용하면 알고리즘의 구조는 그대로  유지하면서 서브클래스에서 특정 단계를 재정의할 수 있습니다|
