
### 공통점 ###
- 어잿든 두 패턴 모두 클라이언트와 구상 형식을 분리시켜주는 역할을 한다
  객체를 만드는 곳을 분리 시킨다 -> 클라이언트는 자신이 사용할 추상 형식만 알면되고, 구상 형식은 다른 곳에서 처리한다
  - 클라이언트 : PizzaStore
  - 추상 형식 : Pizza
  - 다른 곳에서 처리한다 : 구상 피자(CheeasePizaa..)등은 다른 곳에서 만든다

### 차이점 ###
- 팩토리 메소드 -> 상속을 통해서 객체를 만든다
- 추상 팩토리 -> 객체 구성(composition)을 통해서 객체를 만든다

- 팩토리 메소드
    - 연견된 제품을 하나로 묶는다
      ex) NYPizzaStore는 여러 종류의 피자를 만들 수 있다 (NYPizzaStore에 패턴이 사용되어서 비교 대상)
- 추상 팩토리
    - 한종류만 생성이 가능하다
      ex) VeggiePizza2는 VeggiPizza2만 만들 수 있다 (VeggiPizza2에 패턴이 사용되어서 비교 대상)

- !!!총정리!!!
    - 추상 팩토리는 simple factory를 추상화 시킨것과 동일하다!!!!!!
        - 기술적으로는 동일 하지만 simple factory는 PizzaStore에서 구체피자(CheesePizza)를 만들기 때문에 추상화 레벨이 맞지 않지만
          추상 팩토리는 ChicagoPizzaStore에서 구체피자(CheesePizza)를 만들기 때문에 추상화 레벨이 맞다!


### 두 패턴을 사용하면 얻을 수 있는 효과 ###
- PizzaStore -> 구체피자(NYCheese Pizza)이었던 것을
  PizzaStore -> Pizza <- 구체 피자(NYCheese Pizza)로 변경할 수 있다 (아래 이상적인 의존성으로 변경이 됨)

- 이상적인 의존성
    - PizzaStore <-> Pizza
    - NYCheesePizza <-> NYPizzaStore

- 의존성 뒤집기 (Dependency Inversion Principle)
    - 정의 : 추상화된 것에 의존하도록 만들어라. 구상 클래스에 의존하도록 만들지 말아라
    - 풀이 : 고수준 구성요소가 저수준 구성요소에 의존하면 안된다, 항상 추상화에 의존하도록 만들어야 한다
    - 고수준 이란? (무엇가는 사용하는 쪽)
        - PizzaStore는 Pizza를 사용하고 있기 때문에 고수준 구성요소이다
        - 위에서 "사용"은 다른 의미로 저수준 구성요소에 의해 정의가 된다라고 해석할 수도 있다
    - 저수준 이란? (무언가에 사용되는 쪽)
        - Pizza는 PizzaStore에서 사용이 되기 때문에 저수준 구성요소이다
    - 의존성 이란?
        - 어떤 클래스 A가 다른 클래스 또는 인터페이스B를 이용할 때 A가 B에 의존한다고 한다
            - 이때 A를 dependant, B를 dependency라고 한다
            - dependant는 dependency들에게 의존한다
        - 변경에 영향이 가는 경우 A가 B에 의존하고 있다 -> B의 변경에 A가 자유롭지 못하다
        - 서로를 이용하는 두 클래스의 경우에는 coupled라고 한다
    - PizzaStore(NYPizzaStore 등등)들은 Pizza에 의존하고 있다
        - PizzaStore는 Pizza를 직접생성하고 있기 때문 -> Compisition을 활용하면 직접생성을 하지 않기 때문에 의존성을 낮출수 있다
        - 일단 직접 생성을 하면 무조건 의존하고 있다
            - 직접 생성을 하게되면 우선 Pizza의 생성자 변경되는 순간 PizzaStore의 코드도 변경이되어야 하기 때문
    - 뒤집는다?
        - 뒤집는다고 하는 이유는 객체지향을 디자인 할 때 일반적으로 생각하는 방법과는 반대로 뒤집어서 생각해야하기 때문
